//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

class Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8000";

    }

    /**
     * @return OK
     */
    createCategory(body: UpdateCategoryCommand, cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/category/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return OK
     */
    updateCartItemQuantity(body: UpdateCartItemQuantityCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cart/update-item-quantity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateCartItemQuantity(_response);
        });
    }

    protected processUpdateCartItemQuantity(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    ipn(param: MomoCallbackParam, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/momo/ipn?";
        if (param === undefined || param === null)
            throw new Error("The parameter 'param' must be defined and cannot be null.");
        else
            url_ += "param=" + encodeURIComponent("" + param) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIpn(_response);
        });
    }

    protected processIpn(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    updateMyPassword(body: UpdatePasswordCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/update-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMyPassword(_response);
        });
    }

    protected processUpdateMyPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMyAvatar(body: Body | undefined, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/user/update-avatar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMyAvatar(_response);
        });
    }

    protected processUpdateMyAvatar(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    getMyProfile( cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/user/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMyProfile(_response);
        });
    }

    protected processGetMyProfile(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @return OK
     */
    updateMyProfile(body: UpdateProfileCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMyProfile(_response);
        });
    }

    protected processUpdateMyProfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    createProduct(body: CreateProductCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/product/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateProduct(_response);
        });
    }

    protected processCreateProduct(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    createPayment(body: CreatePaymentCommand, cancelToken?: CancelToken | undefined): Promise<CreatePaymentResponse> {
        let url_ = this.baseUrl + "/api/payment/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePayment(_response);
        });
    }

    protected processCreatePayment(response: AxiosResponse): Promise<CreatePaymentResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreatePaymentResponse.fromJS(resultData200);
            return Promise.resolve<CreatePaymentResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreatePaymentResponse>(null as any);
    }

    /**
     * @return OK
     */
    createOrder(body: CreateOrderCommand, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/order/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOrder(_response);
        });
    }

    protected processCreateOrder(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    uploadFile(body: Body2 | undefined, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/file/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    createColor(body: CreateColorCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/color/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateColor(_response);
        });
    }

    protected processCreateColor(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    addToCart(body: AddToCartCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cart/add-to-cart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddToCart(_response);
        });
    }

    protected processAddToCart(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    callback(param: MomoCallbackParam, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/momo/callback?";
        if (param === undefined || param === null)
            throw new Error("The parameter 'param' must be defined and cannot be null.");
        else
            url_ += "param=" + encodeURIComponent("" + param) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCallback(_response);
        });
    }

    protected processCallback(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    getProductById(productId: number, cancelToken?: CancelToken | undefined): Promise<ProductDetailDto> {
        let url_ = this.baseUrl + "/api/product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProductById(_response);
        });
    }

    protected processGetProductById(response: AxiosResponse): Promise<ProductDetailDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductDetailDto.fromJS(resultData200);
            return Promise.resolve<ProductDetailDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDetailDto>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @param forGender (optional) 
     * @param minPrice (optional) 
     * @param maxPrice (optional) 
     * @param includeDeleted (optional) 
     * @param page (optional) 
     * @param size (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getProducts(categoryId: number | undefined, forGender: ForGender | undefined, minPrice: number | undefined, maxPrice: number | undefined, includeDeleted: boolean | undefined, page: number | undefined, size: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedProductBriefDto> {
        let url_ = this.baseUrl + "/api/product/?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (forGender === null)
            throw new Error("The parameter 'forGender' cannot be null.");
        else if (forGender !== undefined)
            url_ += "forGender=" + encodeURIComponent("" + forGender) + "&";
        if (minPrice === null)
            throw new Error("The parameter 'minPrice' cannot be null.");
        else if (minPrice !== undefined)
            url_ += "minPrice=" + encodeURIComponent("" + minPrice) + "&";
        if (maxPrice === null)
            throw new Error("The parameter 'maxPrice' cannot be null.");
        else if (maxPrice !== undefined)
            url_ += "maxPrice=" + encodeURIComponent("" + maxPrice) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProducts(_response);
        });
    }

    protected processGetProducts(response: AxiosResponse): Promise<PaginatedProductBriefDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedProductBriefDto.fromJS(resultData200);
            return Promise.resolve<PaginatedProductBriefDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedProductBriefDto>(null as any);
    }

    /**
     * @param totalPrice (optional) 
     * @return OK
     */
    getDeliveryFee(toProvince: string, toDistrict: string, toWard: string, totalPrice: number | undefined, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/delivery/fee?";
        if (toProvince === undefined || toProvince === null)
            throw new Error("The parameter 'toProvince' must be defined and cannot be null.");
        else
            url_ += "toProvince=" + encodeURIComponent("" + toProvince) + "&";
        if (toDistrict === undefined || toDistrict === null)
            throw new Error("The parameter 'toDistrict' must be defined and cannot be null.");
        else
            url_ += "toDistrict=" + encodeURIComponent("" + toDistrict) + "&";
        if (toWard === undefined || toWard === null)
            throw new Error("The parameter 'toWard' must be defined and cannot be null.");
        else
            url_ += "toWard=" + encodeURIComponent("" + toWard) + "&";
        if (totalPrice === null)
            throw new Error("The parameter 'totalPrice' cannot be null.");
        else if (totalPrice !== undefined)
            url_ += "totalPrice=" + encodeURIComponent("" + totalPrice) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeliveryFee(_response);
        });
    }

    protected processGetDeliveryFee(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param eyword (optional) 
     * @param page (optional) 
     * @param size (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getCategories(eyword: string | undefined, page: number | undefined, size: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedCategoryBriefDto> {
        let url_ = this.baseUrl + "/api/category?";
        if (eyword === null)
            throw new Error("The parameter 'eyword' cannot be null.");
        else if (eyword !== undefined)
            url_ += "eyword=" + encodeURIComponent("" + eyword) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: AxiosResponse): Promise<PaginatedCategoryBriefDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedCategoryBriefDto.fromJS(resultData200);
            return Promise.resolve<PaginatedCategoryBriefDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedCategoryBriefDto>(null as any);
    }

    /**
     * @return OK
     */
    getMyCart( cancelToken?: CancelToken | undefined): Promise<CartItemDto[]> {
        let url_ = this.baseUrl + "/api/cart/my-cart";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMyCart(_response);
        });
    }

    protected processGetMyCart(response: AxiosResponse): Promise<CartItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CartItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CartItemDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CartItemDto[]>(null as any);
    }

    /**
     * @return OK
     */
    deleteCategory(id: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/category/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    clearCart(productOptionId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cart/{productOptionId}";
        if (productOptionId === undefined || productOptionId === null)
            throw new Error("The parameter 'productOptionId' must be defined.");
        url_ = url_.replace("{productOptionId}", encodeURIComponent("" + productOptionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClearCart(_response);
        });
    }

    protected processClearCart(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

class CreateProductClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8000";

    }

    /**
     * @return OK
     */
    1(body: CreateProductOptionCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product-option/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.process1(_response);
        });
    }

    protected process1(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    2(body: CreateProductImageCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product-image/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.process2(_response);
        });
    }

    protected process2(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

class CreateCategoryClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8000";

    }

    /**
     * @return OK
     */
    1(body: CreateCategoryCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/category/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.process1(_response);
        });
    }

    protected process1(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

class ClearCartClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8000";

    }

    /**
     * @return OK
     */
    1( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cart/clear-cart";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.process1(_response);
        });
    }

    protected process1(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

class UpdateCategoryCommand implements IUpdateCategoryCommand {
    id!: number;
    name!: string;
    slug!: string;
    parentId?: number;

    [key: string]: any;

    constructor(data?: IUpdateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["parentId"] = this.parentId;
        return data;
    }
}

interface IUpdateCategoryCommand {
    id: number;
    name: string;
    slug: string;
    parentId?: number;

    [key: string]: any;
}

class UpdateCartItemQuantityCommand implements IUpdateCartItemQuantityCommand {
    productOptionId?: number;
    newQuantity?: number;

    [key: string]: any;

    constructor(data?: IUpdateCartItemQuantityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productOptionId = _data["productOptionId"];
            this.newQuantity = _data["newQuantity"];
        }
    }

    static fromJS(data: any): UpdateCartItemQuantityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCartItemQuantityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productOptionId"] = this.productOptionId;
        data["newQuantity"] = this.newQuantity;
        return data;
    }
}

interface IUpdateCartItemQuantityCommand {
    productOptionId?: number;
    newQuantity?: number;

    [key: string]: any;
}

class MomoCallbackParam implements IMomoCallbackParam {
    partnerCode?: string;
    orderId?: string;
    requestId?: string;
    amount?: number;
    orderInfo?: string;
    orderType?: string;
    transId?: string;
    resultCode?: number;
    message?: string;
    payType?: string;
    responseTime?: number;
    extraData?: string;
    signature?: string;

    [key: string]: any;

    constructor(data?: IMomoCallbackParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.partnerCode = _data["partnerCode"];
            this.orderId = _data["orderId"];
            this.requestId = _data["requestId"];
            this.amount = _data["amount"];
            this.orderInfo = _data["orderInfo"];
            this.orderType = _data["orderType"];
            this.transId = _data["transId"];
            this.resultCode = _data["resultCode"];
            this.message = _data["message"];
            this.payType = _data["payType"];
            this.responseTime = _data["responseTime"];
            this.extraData = _data["extraData"];
            this.signature = _data["signature"];
        }
    }

    static fromJS(data: any): MomoCallbackParam {
        data = typeof data === 'object' ? data : {};
        let result = new MomoCallbackParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["partnerCode"] = this.partnerCode;
        data["orderId"] = this.orderId;
        data["requestId"] = this.requestId;
        data["amount"] = this.amount;
        data["orderInfo"] = this.orderInfo;
        data["orderType"] = this.orderType;
        data["transId"] = this.transId;
        data["resultCode"] = this.resultCode;
        data["message"] = this.message;
        data["payType"] = this.payType;
        data["responseTime"] = this.responseTime;
        data["extraData"] = this.extraData;
        data["signature"] = this.signature;
        return data;
    }
}

interface IMomoCallbackParam {
    partnerCode?: string;
    orderId?: string;
    requestId?: string;
    amount?: number;
    orderInfo?: string;
    orderType?: string;
    transId?: string;
    resultCode?: number;
    message?: string;
    payType?: string;
    responseTime?: number;
    extraData?: string;
    signature?: string;

    [key: string]: any;
}

class UpdatePasswordCommand implements IUpdatePasswordCommand {
    oldPassword!: string;
    newPassword?: string;

    [key: string]: any;

    constructor(data?: IUpdatePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): UpdatePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

interface IUpdatePasswordCommand {
    oldPassword: string;
    newPassword?: string;

    [key: string]: any;
}

class UpdateProfileCommand implements IUpdateProfileCommand {
    firstName!: string;
    lastName!: string;
    email?: string;
    address?: string;
    phoneNumber?: string;

    [key: string]: any;

    constructor(data?: IUpdateProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

interface IUpdateProfileCommand {
    firstName: string;
    lastName: string;
    email?: string;
    address?: string;
    phoneNumber?: string;

    [key: string]: any;
}

class CreateProductCommand implements ICreateProductCommand {
    name!: string;
    forGender?: CreateProductCommandForGender;
    description!: string;
    price!: number;
    discount?: number;
    displayImage!: string;
    brandId?: number;
    categoryId!: number;

    [key: string]: any;

    constructor(data?: ICreateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.forGender = _data["forGender"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.displayImage = _data["displayImage"];
            this.brandId = _data["brandId"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): CreateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["forGender"] = this.forGender;
        data["description"] = this.description;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["displayImage"] = this.displayImage;
        data["brandId"] = this.brandId;
        data["categoryId"] = this.categoryId;
        return data;
    }
}

interface ICreateProductCommand {
    name: string;
    forGender?: CreateProductCommandForGender;
    description: string;
    price: number;
    discount?: number;
    displayImage: string;
    brandId?: number;
    categoryId: number;

    [key: string]: any;
}

class CreateProductOptionCommand implements ICreateProductOptionCommand {
    colorId!: number;
    size!: string;
    stock?: number;
    productId!: number;

    [key: string]: any;

    constructor(data?: ICreateProductOptionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.colorId = _data["colorId"];
            this.size = _data["size"];
            this.stock = _data["stock"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): CreateProductOptionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductOptionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["colorId"] = this.colorId;
        data["size"] = this.size;
        data["stock"] = this.stock;
        data["productId"] = this.productId;
        return data;
    }
}

interface ICreateProductOptionCommand {
    colorId: number;
    size: string;
    stock?: number;
    productId: number;

    [key: string]: any;
}

class CreateProductImageCommand implements ICreateProductImageCommand {
    productId?: number;
    colorId?: number;
    url?: string;

    [key: string]: any;

    constructor(data?: ICreateProductImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productId = _data["productId"];
            this.colorId = _data["colorId"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): CreateProductImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productId"] = this.productId;
        data["colorId"] = this.colorId;
        data["url"] = this.url;
        return data;
    }
}

interface ICreateProductImageCommand {
    productId?: number;
    colorId?: number;
    url?: string;

    [key: string]: any;
}

class CreatePaymentCommand implements ICreatePaymentCommand {
    orderId?: string;

    [key: string]: any;

    constructor(data?: ICreatePaymentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.orderId = _data["orderId"];
        }
    }

    static fromJS(data: any): CreatePaymentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["orderId"] = this.orderId;
        return data;
    }
}

interface ICreatePaymentCommand {
    orderId?: string;

    [key: string]: any;
}

class CreatePaymentResponse implements ICreatePaymentResponse {
    paymentId?: string;
    paymentMethod?: CreatePaymentResponsePaymentMethod;
    orderId?: string;
    redirectUrl?: string;
    mobileUrl?: string;
    redirect?: boolean;

    [key: string]: any;

    constructor(data?: ICreatePaymentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.paymentId = _data["paymentId"];
            this.paymentMethod = _data["paymentMethod"];
            this.orderId = _data["orderId"];
            this.redirectUrl = _data["redirectUrl"];
            this.mobileUrl = _data["mobileUrl"];
            this.redirect = _data["redirect"];
        }
    }

    static fromJS(data: any): CreatePaymentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["paymentId"] = this.paymentId;
        data["paymentMethod"] = this.paymentMethod;
        data["orderId"] = this.orderId;
        data["redirectUrl"] = this.redirectUrl;
        data["mobileUrl"] = this.mobileUrl;
        data["redirect"] = this.redirect;
        return data;
    }
}

interface ICreatePaymentResponse {
    paymentId?: string;
    paymentMethod?: CreatePaymentResponsePaymentMethod;
    orderId?: string;
    redirectUrl?: string;
    mobileUrl?: string;
    redirect?: boolean;

    [key: string]: any;
}

class CreateOrderCommand implements ICreateOrderCommand {
    productOptionIds!: number[];
    customerName!: string;
    address!: string;
    phoneNumber!: string;
    note!: string;
    promotionCode?: string;
    paymentMethod!: CreateOrderCommandPaymentMethod;

    [key: string]: any;

    constructor(data?: ICreateOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.productOptionIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["productOptionIds"])) {
                this.productOptionIds = [] as any;
                for (let item of _data["productOptionIds"])
                    this.productOptionIds!.push(item);
            }
            this.customerName = _data["customerName"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.note = _data["note"];
            this.promotionCode = _data["promotionCode"];
            this.paymentMethod = _data["paymentMethod"];
        }
    }

    static fromJS(data: any): CreateOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.productOptionIds)) {
            data["productOptionIds"] = [];
            for (let item of this.productOptionIds)
                data["productOptionIds"].push(item);
        }
        data["customerName"] = this.customerName;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["note"] = this.note;
        data["promotionCode"] = this.promotionCode;
        data["paymentMethod"] = this.paymentMethod;
        return data;
    }
}

interface ICreateOrderCommand {
    productOptionIds: number[];
    customerName: string;
    address: string;
    phoneNumber: string;
    note: string;
    promotionCode?: string;
    paymentMethod: CreateOrderCommandPaymentMethod;

    [key: string]: any;
}

class CreateColorCommand implements ICreateColorCommand {
    name!: string;
    image?: string;

    [key: string]: any;

    constructor(data?: ICreateColorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): CreateColorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateColorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["image"] = this.image;
        return data;
    }
}

interface ICreateColorCommand {
    name: string;
    image?: string;

    [key: string]: any;
}

class CreateCategoryCommand implements ICreateCategoryCommand {
    name!: string;
    parentId?: number;

    [key: string]: any;

    constructor(data?: ICreateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        return data;
    }
}

interface ICreateCategoryCommand {
    name: string;
    parentId?: number;

    [key: string]: any;
}

class AddToCartCommand implements IAddToCartCommand {
    productOptionId?: number;
    quantity?: number;

    [key: string]: any;

    constructor(data?: IAddToCartCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productOptionId = _data["productOptionId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): AddToCartCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddToCartCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productOptionId"] = this.productOptionId;
        data["quantity"] = this.quantity;
        return data;
    }
}

interface IAddToCartCommand {
    productOptionId?: number;
    quantity?: number;

    [key: string]: any;
}

class UserDto implements IUserDto {
    userId?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    phoneNumber?: string;
    address?: string;
    avatarUrl?: string;
    createdAt?: Date;
    permissions?: string[];
    customer?: boolean;
    emailVerified?: boolean;
    accountEnabled?: boolean;

    [key: string]: any;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.avatarUrl = _data["avatarUrl"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.customer = _data["customer"];
            this.emailVerified = _data["emailVerified"];
            this.accountEnabled = _data["accountEnabled"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["avatarUrl"] = this.avatarUrl;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["customer"] = this.customer;
        data["emailVerified"] = this.emailVerified;
        data["accountEnabled"] = this.accountEnabled;
        return data;
    }
}

interface IUserDto {
    userId?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    phoneNumber?: string;
    address?: string;
    avatarUrl?: string;
    createdAt?: Date;
    permissions?: string[];
    customer?: boolean;
    emailVerified?: boolean;
    accountEnabled?: boolean;

    [key: string]: any;
}

class CategoryBriefDto implements ICategoryBriefDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    categoryId?: number;
    name?: string;
    slug?: string;
    parent?: CategoryBriefDto;

    [key: string]: any;

    constructor(data?: ICategoryBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.parent = _data["parent"] ? CategoryBriefDto.fromJS(_data["parent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CategoryBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        return data;
    }
}

interface ICategoryBriefDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    categoryId?: number;
    name?: string;
    slug?: string;
    parent?: CategoryBriefDto;

    [key: string]: any;
}

class ColorDto implements IColorDto {
    colorId?: number;
    name?: string;
    image?: string;

    [key: string]: any;

    constructor(data?: IColorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.colorId = _data["colorId"];
            this.name = _data["name"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): ColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["colorId"] = this.colorId;
        data["name"] = this.name;
        data["image"] = this.image;
        return data;
    }
}

interface IColorDto {
    colorId?: number;
    name?: string;
    image?: string;

    [key: string]: any;
}

class ProductDetailDto implements IProductDetailDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productId?: number;
    name?: string;
    forGender?: ProductDetailDtoForGender;
    slug?: string;
    price?: number;
    discount?: number;
    displayImage?: string;
    category?: CategoryBriefDto;
    deletedDate?: Date;
    productOptions?: ProductOptionDto[];
    images?: ProductImageDto[];
    description?: string;

    [key: string]: any;

    constructor(data?: IProductDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.forGender = _data["forGender"];
            this.slug = _data["slug"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.displayImage = _data["displayImage"];
            this.category = _data["category"] ? CategoryBriefDto.fromJS(_data["category"]) : <any>undefined;
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["productOptions"])) {
                this.productOptions = [] as any;
                for (let item of _data["productOptions"])
                    this.productOptions!.push(ProductOptionDto.fromJS(item));
            }
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ProductImageDto.fromJS(item));
            }
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ProductDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["forGender"] = this.forGender;
        data["slug"] = this.slug;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["displayImage"] = this.displayImage;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        if (Array.isArray(this.productOptions)) {
            data["productOptions"] = [];
            for (let item of this.productOptions)
                data["productOptions"].push(item.toJSON());
        }
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["description"] = this.description;
        return data;
    }
}

interface IProductDetailDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productId?: number;
    name?: string;
    forGender?: ProductDetailDtoForGender;
    slug?: string;
    price?: number;
    discount?: number;
    displayImage?: string;
    category?: CategoryBriefDto;
    deletedDate?: Date;
    productOptions?: ProductOptionDto[];
    images?: ProductImageDto[];
    description?: string;

    [key: string]: any;
}

class ProductImageDto implements IProductImageDto {
    url?: string;
    forColor?: ColorDto;

    [key: string]: any;

    constructor(data?: IProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.url = _data["url"];
            this.forColor = _data["forColor"] ? ColorDto.fromJS(_data["forColor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["url"] = this.url;
        data["forColor"] = this.forColor ? this.forColor.toJSON() : <any>undefined;
        return data;
    }
}

interface IProductImageDto {
    url?: string;
    forColor?: ColorDto;

    [key: string]: any;
}

class ProductOptionDto implements IProductOptionDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productOptionId?: number;
    size?: string;
    stock?: number;
    deletedDate?: Date;
    color?: ColorDto;

    [key: string]: any;

    constructor(data?: IProductOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.productOptionId = _data["productOptionId"];
            this.size = _data["size"];
            this.stock = _data["stock"];
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
            this.color = _data["color"] ? ColorDto.fromJS(_data["color"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["productOptionId"] = this.productOptionId;
        data["size"] = this.size;
        data["stock"] = this.stock;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        return data;
    }
}

interface IProductOptionDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productOptionId?: number;
    size?: string;
    stock?: number;
    deletedDate?: Date;
    color?: ColorDto;

    [key: string]: any;
}

class PaginatedProductBriefDto implements IPaginatedProductBriefDto {
    data?: ProductBriefDto[];
    page?: number;
    size?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedProductBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductBriefDto.fromJS(item));
            }
            this.page = _data["page"];
            this.size = _data["size"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedProductBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedProductBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["size"] = this.size;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedProductBriefDto {
    data?: ProductBriefDto[];
    page?: number;
    size?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class ProductBriefDto implements IProductBriefDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productId?: number;
    name?: string;
    forGender?: ProductBriefDtoForGender;
    slug?: string;
    price?: number;
    discount?: number;
    displayImage?: string;
    category?: CategoryBriefDto;
    deletedDate?: Date;

    [key: string]: any;

    constructor(data?: IProductBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.forGender = _data["forGender"];
            this.slug = _data["slug"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.displayImage = _data["displayImage"];
            this.category = _data["category"] ? CategoryBriefDto.fromJS(_data["category"]) : <any>undefined;
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["forGender"] = this.forGender;
        data["slug"] = this.slug;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["displayImage"] = this.displayImage;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        return data;
    }
}

interface IProductBriefDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productId?: number;
    name?: string;
    forGender?: ProductBriefDtoForGender;
    slug?: string;
    price?: number;
    discount?: number;
    displayImage?: string;
    category?: CategoryBriefDto;
    deletedDate?: Date;

    [key: string]: any;
}

class PaginatedCategoryBriefDto implements IPaginatedCategoryBriefDto {
    data?: CategoryBriefDto[];
    page?: number;
    size?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedCategoryBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryBriefDto.fromJS(item));
            }
            this.page = _data["page"];
            this.size = _data["size"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedCategoryBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedCategoryBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["size"] = this.size;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedCategoryBriefDto {
    data?: CategoryBriefDto[];
    page?: number;
    size?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class CartItemDto implements ICartItemDto {
    userId?: string;
    productOptionId?: number;
    quantity?: number;
    productOption?: ProductOptionDetailDto;

    [key: string]: any;

    constructor(data?: ICartItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.productOptionId = _data["productOptionId"];
            this.quantity = _data["quantity"];
            this.productOption = _data["productOption"] ? ProductOptionDetailDto.fromJS(_data["productOption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CartItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CartItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["productOptionId"] = this.productOptionId;
        data["quantity"] = this.quantity;
        data["productOption"] = this.productOption ? this.productOption.toJSON() : <any>undefined;
        return data;
    }
}

interface ICartItemDto {
    userId?: string;
    productOptionId?: number;
    quantity?: number;
    productOption?: ProductOptionDetailDto;

    [key: string]: any;
}

class ProductOptionDetailDto implements IProductOptionDetailDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productOptionId?: number;
    size?: string;
    stock?: number;
    deletedDate?: Date;
    color?: ColorDto;
    product?: ProductBriefDto;

    [key: string]: any;

    constructor(data?: IProductOptionDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.productOptionId = _data["productOptionId"];
            this.size = _data["size"];
            this.stock = _data["stock"];
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
            this.color = _data["color"] ? ColorDto.fromJS(_data["color"]) : <any>undefined;
            this.product = _data["product"] ? ProductBriefDto.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductOptionDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["productOptionId"] = this.productOptionId;
        data["size"] = this.size;
        data["stock"] = this.stock;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

interface IProductOptionDetailDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productOptionId?: number;
    size?: string;
    stock?: number;
    deletedDate?: Date;
    color?: ColorDto;
    product?: ProductBriefDto;

    [key: string]: any;
}

class Body implements IBody {
    file!: string;

    [key: string]: any;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["file"] = this.file;
        return data;
    }
}

interface IBody {
    file: string;

    [key: string]: any;
}

class Body2 implements IBody2 {
    file?: string;

    [key: string]: any;

    constructor(data?: IBody2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): Body2 {
        data = typeof data === 'object' ? data : {};
        let result = new Body2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["file"] = this.file;
        return data;
    }
}

interface IBody2 {
    file?: string;

    [key: string]: any;
}

enum ForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum CreateProductCommandForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum CreatePaymentResponsePaymentMethod {
    COD = "COD",
    MOMO_QR = "MOMO_QR",
    MOMO_ATM = "MOMO_ATM",
}

enum CreateOrderCommandPaymentMethod {
    COD = "COD",
    MOMO_QR = "MOMO_QR",
    MOMO_ATM = "MOMO_ATM",
}

enum ProductDetailDtoForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum ProductBriefDtoForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

interface FileParameter {
    data: any;
    fileName: string;
}

class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}