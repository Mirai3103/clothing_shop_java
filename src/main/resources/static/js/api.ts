//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

class Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8000";

    }

    /**
     * @return OK
     */
    updateProduct(body: UpdateProductCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateProduct(_response);
        });
    }

    protected processUpdateProduct(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    createCategory(body: UpdateCategoryCommand, cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/category/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @return OK
     */
    updateCartItemQuantity(body: UpdateCartItemQuantityCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cart/update-item-quantity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateCartItemQuantity(_response);
        });
    }

    protected processUpdateCartItemQuantity(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    ipn(param: MomoCallbackParam, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/momo/ipn?";
        if (param === undefined || param === null)
            throw new Error("The parameter 'param' must be defined and cannot be null.");
        else
            url_ += "param=" + encodeURIComponent("" + param) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIpn(_response);
        });
    }

    protected processIpn(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    updateMyPassword(body: UpdatePasswordCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/update-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMyPassword(_response);
        });
    }

    protected processUpdateMyPassword(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    updateMyAvatar(body: Body | undefined, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/user/update-avatar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMyAvatar(_response);
        });
    }

    protected processUpdateMyAvatar(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    getMyProfile( cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/user/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMyProfile(_response);
        });
    }

    protected processGetMyProfile(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @return OK
     */
    updateMyProfile(body: UpdateProfileCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/user/my-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMyProfile(_response);
        });
    }

    protected processUpdateMyProfile(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    createProduct(body: CreateProductCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/product/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateProduct(_response);
        });
    }

    protected processCreateProduct(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    createProductOption(body: CreateProductOptionCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/product-option/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateProductOption(_response);
        });
    }

    protected processCreateProductOption(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    createProductImage(body: CreateProductImageCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product-image/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateProductImage(_response);
        });
    }

    protected processCreateProductImage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    createPayment(body: CreatePaymentCommand, cancelToken?: CancelToken | undefined): Promise<CreatePaymentResponse> {
        let url_ = this.baseUrl + "/api/payment/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePayment(_response);
        });
    }

    protected processCreatePayment(response: AxiosResponse): Promise<CreatePaymentResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CreatePaymentResponse.fromJS(resultData200);
            return Promise.resolve<CreatePaymentResponse>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreatePaymentResponse>(null as any);
    }

    /**
     * @return OK
     */
    createOrder(body: CreateOrderCommand, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/order/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOrder(_response);
        });
    }

    protected processCreateOrder(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    uploadFiles(files: FileParameter[], cancelToken?: CancelToken | undefined): Promise<string[]> {
        let url_ = this.baseUrl + "/api/file/uploads?";
        if (files === undefined || files === null)
            throw new Error("The parameter 'files' must be defined and cannot be null.");
        else
            files && files.forEach(item => { url_ += "files=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadFiles(_response);
        });
    }

    protected processUploadFiles(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<string[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    uploadFile(body: Body2 | undefined, cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/file/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUploadFile(_response);
        });
    }

    protected processUploadFile(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return OK
     */
    getDeliveryOption(body: GetDeliveryOptionQuery, cancelToken?: CancelToken | undefined): Promise<GetValidShipServiceResponse[]> {
        let url_ = this.baseUrl + "/api/delivery/option";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeliveryOption(_response);
        });
    }

    protected processGetDeliveryOption(response: AxiosResponse): Promise<GetValidShipServiceResponse[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetValidShipServiceResponse.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<GetValidShipServiceResponse[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetValidShipServiceResponse[]>(null as any);
    }

    /**
     * @return OK
     */
    getDeliveryFee(body: GetDeliveryFeeQuery, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/delivery/fee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDeliveryFee(_response);
        });
    }

    protected processGetDeliveryFee(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    createColor(body: CreateColorCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/color/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateColor(_response);
        });
    }

    protected processCreateColor(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    addToCart(body: AddToCartCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cart/add-to-cart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddToCart(_response);
        });
    }

    protected processAddToCart(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param code (optional) 
     * @param orderValue (optional) 
     * @return OK
     */
    checkPromotion(code: string | undefined, orderValue: number | undefined, cancelToken?: CancelToken | undefined): Promise<PromotionDto> {
        let url_ = this.baseUrl + "/api/promotion/check?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (orderValue === null)
            throw new Error("The parameter 'orderValue' cannot be null.");
        else if (orderValue !== undefined)
            url_ += "orderValue=" + encodeURIComponent("" + orderValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckPromotion(_response);
        });
    }

    protected processCheckPromotion(response: AxiosResponse): Promise<PromotionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PromotionDto.fromJS(resultData200);
            return Promise.resolve<PromotionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PromotionDto>(null as any);
    }

    /**
     * @return OK
     */
    getProductById(productId: number, cancelToken?: CancelToken | undefined): Promise<ProductDetailDto> {
        let url_ = this.baseUrl + "/api/product/{productId}";
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProductById(_response);
        });
    }

    protected processGetProductById(response: AxiosResponse): Promise<ProductDetailDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ProductDetailDto.fromJS(resultData200);
            return Promise.resolve<ProductDetailDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ProductDetailDto>(null as any);
    }

    /**
     * @param categoryId (optional) 
     * @param forGender (optional) 
     * @param minPrice (optional) 
     * @param maxPrice (optional) 
     * @param includeDeleted (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getProducts(categoryId: number | undefined, forGender: ForGender | undefined, minPrice: number | undefined, maxPrice: number | undefined, includeDeleted: boolean | undefined, page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedProductBriefDto> {
        let url_ = this.baseUrl + "/api/product/?";
        if (categoryId === null)
            throw new Error("The parameter 'categoryId' cannot be null.");
        else if (categoryId !== undefined)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (forGender === null)
            throw new Error("The parameter 'forGender' cannot be null.");
        else if (forGender !== undefined)
            url_ += "forGender=" + encodeURIComponent("" + forGender) + "&";
        if (minPrice === null)
            throw new Error("The parameter 'minPrice' cannot be null.");
        else if (minPrice !== undefined)
            url_ += "minPrice=" + encodeURIComponent("" + minPrice) + "&";
        if (maxPrice === null)
            throw new Error("The parameter 'maxPrice' cannot be null.");
        else if (maxPrice !== undefined)
            url_ += "maxPrice=" + encodeURIComponent("" + maxPrice) + "&";
        if (includeDeleted === null)
            throw new Error("The parameter 'includeDeleted' cannot be null.");
        else if (includeDeleted !== undefined)
            url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetProducts(_response);
        });
    }

    protected processGetProducts(response: AxiosResponse): Promise<PaginatedProductBriefDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedProductBriefDto.fromJS(resultData200);
            return Promise.resolve<PaginatedProductBriefDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedProductBriefDto>(null as any);
    }

    /**
     * @param paymentStatus (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param orderStatus (optional) 
     * @param amountFrom (optional) 
     * @param amountTo (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getAllOrders(paymentStatus: PaymentStatus | undefined, startDate: Date | undefined, endDate: Date | undefined, orderStatus: OrderStatus | undefined, amountFrom: number | undefined, amountTo: number | undefined, page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedOrderBriefDto> {
        let url_ = this.baseUrl + "/api/order?";
        if (paymentStatus === null)
            throw new Error("The parameter 'paymentStatus' cannot be null.");
        else if (paymentStatus !== undefined)
            url_ += "paymentStatus=" + encodeURIComponent("" + paymentStatus) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toISOString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toISOString() : "") + "&";
        if (orderStatus === null)
            throw new Error("The parameter 'orderStatus' cannot be null.");
        else if (orderStatus !== undefined)
            url_ += "orderStatus=" + encodeURIComponent("" + orderStatus) + "&";
        if (amountFrom === null)
            throw new Error("The parameter 'amountFrom' cannot be null.");
        else if (amountFrom !== undefined)
            url_ += "amountFrom=" + encodeURIComponent("" + amountFrom) + "&";
        if (amountTo === null)
            throw new Error("The parameter 'amountTo' cannot be null.");
        else if (amountTo !== undefined)
            url_ += "amountTo=" + encodeURIComponent("" + amountTo) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllOrders(_response);
        });
    }

    protected processGetAllOrders(response: AxiosResponse): Promise<PaginatedOrderBriefDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedOrderBriefDto.fromJS(resultData200);
            return Promise.resolve<PaginatedOrderBriefDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedOrderBriefDto>(null as any);
    }

    /**
     * @param eyword (optional) 
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param sortField (optional) 
     * @param sortDir (optional) 
     * @param keyword (optional) 
     * @return OK
     */
    getCategories(eyword: string | undefined, page: number | undefined, pageSize: number | undefined, sortField: string | undefined, sortDir: string | undefined, keyword: string | undefined, cancelToken?: CancelToken | undefined): Promise<PaginatedCategoryBriefDto> {
        let url_ = this.baseUrl + "/api/category?";
        if (eyword === null)
            throw new Error("The parameter 'eyword' cannot be null.");
        else if (eyword !== undefined)
            url_ += "eyword=" + encodeURIComponent("" + eyword) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortField === null)
            throw new Error("The parameter 'sortField' cannot be null.");
        else if (sortField !== undefined)
            url_ += "sortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortDir === null)
            throw new Error("The parameter 'sortDir' cannot be null.");
        else if (sortDir !== undefined)
            url_ += "sortDir=" + encodeURIComponent("" + sortDir) + "&";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "keyword=" + encodeURIComponent("" + keyword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: AxiosResponse): Promise<PaginatedCategoryBriefDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PaginatedCategoryBriefDto.fromJS(resultData200);
            return Promise.resolve<PaginatedCategoryBriefDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PaginatedCategoryBriefDto>(null as any);
    }

    /**
     * @return OK
     */
    getAllCategoriesGroupByParent( cancelToken?: CancelToken | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/category/getAllCategoriesGroupByParent";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllCategoriesGroupByParent(_response);
        });
    }

    protected processGetAllCategoriesGroupByParent(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return Promise.resolve({ fileName: fileName, status: status, data: new Blob([response.data], { type: response.headers["content-type"] }), headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @return OK
     */
    getMyCart( cancelToken?: CancelToken | undefined): Promise<CartItemDto[]> {
        let url_ = this.baseUrl + "/api/cart/my-cart";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMyCart(_response);
        });
    }

    protected processGetMyCart(response: AxiosResponse): Promise<CartItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CartItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CartItemDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CartItemDto[]>(null as any);
    }

    /**
     * @return OK
     */
    deleteProductOption(id: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product-option/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteProductOption(_response);
        });
    }

    protected processDeleteProductOption(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteProductImage(body: DeleteProductImageCommand, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/product-image/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "DELETE",
            url: url_,
            headers: {
                "Content-Type": "application/json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteProductImage(_response);
        });
    }

    protected processDeleteProductImage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    deleteCategory(id: string, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/category/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    clearCart(productOptionId: number, cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cart/{productOptionId}";
        if (productOptionId === undefined || productOptionId === null)
            throw new Error("The parameter 'productOptionId' must be defined.");
        url_ = url_.replace("{productOptionId}", encodeURIComponent("" + productOptionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processClearCart(_response);
        });
    }

    protected processClearCart(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

class CreateCategoryClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8000";

    }

    /**
     * @return OK
     */
    1(body: CreateCategoryCommand, cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/category/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "*/*"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.process1(_response);
        });
    }

    protected process1(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }
}

class ClearCartClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8000";

    }

    /**
     * @return OK
     */
    1( cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/cart/clear-cart";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.process1(_response);
        });
    }

    protected process1(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

class UpdateProductCommand implements IUpdateProductCommand {
    productId!: number;
    name!: string;
    forGender?: UpdateProductCommandForGender;
    description!: string;
    price!: number;
    discount?: number;
    displayImage!: string;
    brandId?: number;
    categoryId!: number;

    [key: string]: any;

    constructor(data?: IUpdateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.forGender = _data["forGender"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.displayImage = _data["displayImage"];
            this.brandId = _data["brandId"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): UpdateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["forGender"] = this.forGender;
        data["description"] = this.description;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["displayImage"] = this.displayImage;
        data["brandId"] = this.brandId;
        data["categoryId"] = this.categoryId;
        return data;
    }
}

interface IUpdateProductCommand {
    productId: number;
    name: string;
    forGender?: UpdateProductCommandForGender;
    description: string;
    price: number;
    discount?: number;
    displayImage: string;
    brandId?: number;
    categoryId: number;

    [key: string]: any;
}

class UpdateCategoryCommand implements IUpdateCategoryCommand {
    id!: number;
    name!: string;
    slug!: string;
    parentId?: number;

    [key: string]: any;

    constructor(data?: IUpdateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["parentId"] = this.parentId;
        return data;
    }
}

interface IUpdateCategoryCommand {
    id: number;
    name: string;
    slug: string;
    parentId?: number;

    [key: string]: any;
}

class UpdateCartItemQuantityCommand implements IUpdateCartItemQuantityCommand {
    productOptionId?: number;
    newQuantity?: number;

    [key: string]: any;

    constructor(data?: IUpdateCartItemQuantityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productOptionId = _data["productOptionId"];
            this.newQuantity = _data["newQuantity"];
        }
    }

    static fromJS(data: any): UpdateCartItemQuantityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCartItemQuantityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productOptionId"] = this.productOptionId;
        data["newQuantity"] = this.newQuantity;
        return data;
    }
}

interface IUpdateCartItemQuantityCommand {
    productOptionId?: number;
    newQuantity?: number;

    [key: string]: any;
}

class MomoCallbackParam implements IMomoCallbackParam {
    partnerCode?: string;
    orderId?: string;
    requestId?: string;
    amount?: number;
    orderInfo?: string;
    orderType?: string;
    transId?: string;
    resultCode?: number;
    message?: string;
    payType?: string;
    responseTime?: number;
    extraData?: string;
    signature?: string;

    [key: string]: any;

    constructor(data?: IMomoCallbackParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.partnerCode = _data["partnerCode"];
            this.orderId = _data["orderId"];
            this.requestId = _data["requestId"];
            this.amount = _data["amount"];
            this.orderInfo = _data["orderInfo"];
            this.orderType = _data["orderType"];
            this.transId = _data["transId"];
            this.resultCode = _data["resultCode"];
            this.message = _data["message"];
            this.payType = _data["payType"];
            this.responseTime = _data["responseTime"];
            this.extraData = _data["extraData"];
            this.signature = _data["signature"];
        }
    }

    static fromJS(data: any): MomoCallbackParam {
        data = typeof data === 'object' ? data : {};
        let result = new MomoCallbackParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["partnerCode"] = this.partnerCode;
        data["orderId"] = this.orderId;
        data["requestId"] = this.requestId;
        data["amount"] = this.amount;
        data["orderInfo"] = this.orderInfo;
        data["orderType"] = this.orderType;
        data["transId"] = this.transId;
        data["resultCode"] = this.resultCode;
        data["message"] = this.message;
        data["payType"] = this.payType;
        data["responseTime"] = this.responseTime;
        data["extraData"] = this.extraData;
        data["signature"] = this.signature;
        return data;
    }
}

interface IMomoCallbackParam {
    partnerCode?: string;
    orderId?: string;
    requestId?: string;
    amount?: number;
    orderInfo?: string;
    orderType?: string;
    transId?: string;
    resultCode?: number;
    message?: string;
    payType?: string;
    responseTime?: number;
    extraData?: string;
    signature?: string;

    [key: string]: any;
}

class UpdatePasswordCommand implements IUpdatePasswordCommand {
    oldPassword!: string;
    newPassword?: string;

    [key: string]: any;

    constructor(data?: IUpdatePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): UpdatePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

interface IUpdatePasswordCommand {
    oldPassword: string;
    newPassword?: string;

    [key: string]: any;
}

class UpdateProfileCommand implements IUpdateProfileCommand {
    firstName!: string;
    lastName!: string;
    email?: string;
    address?: string;
    phoneNumber?: string;

    [key: string]: any;

    constructor(data?: IUpdateProfileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): UpdateProfileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

interface IUpdateProfileCommand {
    firstName: string;
    lastName: string;
    email?: string;
    address?: string;
    phoneNumber?: string;

    [key: string]: any;
}

class CreateProductCommand implements ICreateProductCommand {
    name!: string;
    forGender?: CreateProductCommandForGender;
    description!: string;
    price!: number;
    discount?: number;
    displayImage!: string;
    brandId?: number;
    categoryId!: number;

    [key: string]: any;

    constructor(data?: ICreateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.forGender = _data["forGender"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.displayImage = _data["displayImage"];
            this.brandId = _data["brandId"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): CreateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["forGender"] = this.forGender;
        data["description"] = this.description;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["displayImage"] = this.displayImage;
        data["brandId"] = this.brandId;
        data["categoryId"] = this.categoryId;
        return data;
    }
}

interface ICreateProductCommand {
    name: string;
    forGender?: CreateProductCommandForGender;
    description: string;
    price: number;
    discount?: number;
    displayImage: string;
    brandId?: number;
    categoryId: number;

    [key: string]: any;
}

class CreateProductOptionCommand implements ICreateProductOptionCommand {
    colorName!: string;
    size!: string;
    stock?: number;
    productId!: number;

    [key: string]: any;

    constructor(data?: ICreateProductOptionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.colorName = _data["colorName"];
            this.size = _data["size"];
            this.stock = _data["stock"];
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): CreateProductOptionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductOptionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["colorName"] = this.colorName;
        data["size"] = this.size;
        data["stock"] = this.stock;
        data["productId"] = this.productId;
        return data;
    }
}

interface ICreateProductOptionCommand {
    colorName: string;
    size: string;
    stock?: number;
    productId: number;

    [key: string]: any;
}

class CreateProductImageCommand implements ICreateProductImageCommand {
    productId?: number;
    colorId?: number;
    url?: string;

    [key: string]: any;

    constructor(data?: ICreateProductImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productId = _data["productId"];
            this.colorId = _data["colorId"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): CreateProductImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productId"] = this.productId;
        data["colorId"] = this.colorId;
        data["url"] = this.url;
        return data;
    }
}

interface ICreateProductImageCommand {
    productId?: number;
    colorId?: number;
    url?: string;

    [key: string]: any;
}

class CreatePaymentCommand implements ICreatePaymentCommand {
    orderId?: string;

    [key: string]: any;

    constructor(data?: ICreatePaymentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.orderId = _data["orderId"];
        }
    }

    static fromJS(data: any): CreatePaymentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["orderId"] = this.orderId;
        return data;
    }
}

interface ICreatePaymentCommand {
    orderId?: string;

    [key: string]: any;
}

class CreatePaymentResponse implements ICreatePaymentResponse {
    paymentId?: string;
    paymentMethod?: CreatePaymentResponsePaymentMethod;
    orderId?: string;
    redirectUrl?: string;
    mobileUrl?: string;
    redirect?: boolean;

    [key: string]: any;

    constructor(data?: ICreatePaymentResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.paymentId = _data["paymentId"];
            this.paymentMethod = _data["paymentMethod"];
            this.orderId = _data["orderId"];
            this.redirectUrl = _data["redirectUrl"];
            this.mobileUrl = _data["mobileUrl"];
            this.redirect = _data["redirect"];
        }
    }

    static fromJS(data: any): CreatePaymentResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["paymentId"] = this.paymentId;
        data["paymentMethod"] = this.paymentMethod;
        data["orderId"] = this.orderId;
        data["redirectUrl"] = this.redirectUrl;
        data["mobileUrl"] = this.mobileUrl;
        data["redirect"] = this.redirect;
        return data;
    }
}

interface ICreatePaymentResponse {
    paymentId?: string;
    paymentMethod?: CreatePaymentResponsePaymentMethod;
    orderId?: string;
    redirectUrl?: string;
    mobileUrl?: string;
    redirect?: boolean;

    [key: string]: any;
}

class CreateOrderCommand implements ICreateOrderCommand {
    orderItems!: OrderItem[];
    customerName!: string;
    address!: string;
    phoneNumber!: string;
    email?: string;
    note?: string;
    promotionCode?: string;
    paymentMethod!: CreateOrderCommandPaymentMethod;
    shipServiceId?: string;

    [key: string]: any;

    constructor(data?: ICreateOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.orderItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItem.fromJS(item));
            }
            this.customerName = _data["customerName"];
            this.address = _data["address"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.note = _data["note"];
            this.promotionCode = _data["promotionCode"];
            this.paymentMethod = _data["paymentMethod"];
            this.shipServiceId = _data["shipServiceId"];
        }
    }

    static fromJS(data: any): CreateOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item.toJSON());
        }
        data["customerName"] = this.customerName;
        data["address"] = this.address;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["note"] = this.note;
        data["promotionCode"] = this.promotionCode;
        data["paymentMethod"] = this.paymentMethod;
        data["shipServiceId"] = this.shipServiceId;
        return data;
    }
}

interface ICreateOrderCommand {
    orderItems: OrderItem[];
    customerName: string;
    address: string;
    phoneNumber: string;
    email?: string;
    note?: string;
    promotionCode?: string;
    paymentMethod: CreateOrderCommandPaymentMethod;
    shipServiceId?: string;

    [key: string]: any;
}

class OrderItem implements IOrderItem {
    productOptionId?: number;
    quantity?: number;

    [key: string]: any;

    constructor(data?: IOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productOptionId = _data["productOptionId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): OrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productOptionId"] = this.productOptionId;
        data["quantity"] = this.quantity;
        return data;
    }
}

interface IOrderItem {
    productOptionId?: number;
    quantity?: number;

    [key: string]: any;
}

class GetDeliveryOptionQuery implements IGetDeliveryOptionQuery {
    toAddress?: string;
    orderValue?: number;
    cod?: number;
    widthInCm?: number;
    heightInCm?: number;
    lengthInCm?: number;
    weightInGram?: number;
    toDistrict?: string;
    toWard?: string;
    toDetailAddress?: string;
    toProvince?: string;

    [key: string]: any;

    constructor(data?: IGetDeliveryOptionQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.toAddress = _data["toAddress"];
            this.orderValue = _data["orderValue"];
            this.cod = _data["cod"];
            this.widthInCm = _data["widthInCm"];
            this.heightInCm = _data["heightInCm"];
            this.lengthInCm = _data["lengthInCm"];
            this.weightInGram = _data["weightInGram"];
            this.toDistrict = _data["toDistrict"];
            this.toWard = _data["toWard"];
            this.toDetailAddress = _data["toDetailAddress"];
            this.toProvince = _data["toProvince"];
        }
    }

    static fromJS(data: any): GetDeliveryOptionQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeliveryOptionQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["toAddress"] = this.toAddress;
        data["orderValue"] = this.orderValue;
        data["cod"] = this.cod;
        data["widthInCm"] = this.widthInCm;
        data["heightInCm"] = this.heightInCm;
        data["lengthInCm"] = this.lengthInCm;
        data["weightInGram"] = this.weightInGram;
        data["toDistrict"] = this.toDistrict;
        data["toWard"] = this.toWard;
        data["toDetailAddress"] = this.toDetailAddress;
        data["toProvince"] = this.toProvince;
        return data;
    }
}

interface IGetDeliveryOptionQuery {
    toAddress?: string;
    orderValue?: number;
    cod?: number;
    widthInCm?: number;
    heightInCm?: number;
    lengthInCm?: number;
    weightInGram?: number;
    toDistrict?: string;
    toWard?: string;
    toDetailAddress?: string;
    toProvince?: string;

    [key: string]: any;
}

class GetValidShipServiceResponse implements IGetValidShipServiceResponse {
    id?: string;
    carrierName?: string;
    carrierLogo?: string;
    service?: string;
    expected?: string;
    totalFree?: number;
    totalAmount?: number;

    [key: string]: any;

    constructor(data?: IGetValidShipServiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.carrierName = _data["carrierName"];
            this.carrierLogo = _data["carrierLogo"];
            this.service = _data["service"];
            this.expected = _data["expected"];
            this.totalFree = _data["totalFree"];
            this.totalAmount = _data["totalAmount"];
        }
    }

    static fromJS(data: any): GetValidShipServiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetValidShipServiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["carrierName"] = this.carrierName;
        data["carrierLogo"] = this.carrierLogo;
        data["service"] = this.service;
        data["expected"] = this.expected;
        data["totalFree"] = this.totalFree;
        data["totalAmount"] = this.totalAmount;
        return data;
    }
}

interface IGetValidShipServiceResponse {
    id?: string;
    carrierName?: string;
    carrierLogo?: string;
    service?: string;
    expected?: string;
    totalFree?: number;
    totalAmount?: number;

    [key: string]: any;
}

class GetDeliveryFeeQuery implements IGetDeliveryFeeQuery {
    toProvince!: string;
    toDistrict!: string;
    toWard!: string;
    totalPrice?: number;

    [key: string]: any;

    constructor(data?: IGetDeliveryFeeQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.toProvince = _data["toProvince"];
            this.toDistrict = _data["toDistrict"];
            this.toWard = _data["toWard"];
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): GetDeliveryFeeQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeliveryFeeQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["toProvince"] = this.toProvince;
        data["toDistrict"] = this.toDistrict;
        data["toWard"] = this.toWard;
        data["totalPrice"] = this.totalPrice;
        return data;
    }
}

interface IGetDeliveryFeeQuery {
    toProvince: string;
    toDistrict: string;
    toWard: string;
    totalPrice?: number;

    [key: string]: any;
}

class CreateColorCommand implements ICreateColorCommand {
    name!: string;
    image?: string;

    [key: string]: any;

    constructor(data?: ICreateColorCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): CreateColorCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateColorCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["image"] = this.image;
        return data;
    }
}

interface ICreateColorCommand {
    name: string;
    image?: string;

    [key: string]: any;
}

class CreateCategoryCommand implements ICreateCategoryCommand {
    name!: string;
    parentId?: number;

    [key: string]: any;

    constructor(data?: ICreateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.parentId = _data["parentId"];
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["parentId"] = this.parentId;
        return data;
    }
}

interface ICreateCategoryCommand {
    name: string;
    parentId?: number;

    [key: string]: any;
}

class AddToCartCommand implements IAddToCartCommand {
    productOptionId?: number;
    quantity?: number;

    [key: string]: any;

    constructor(data?: IAddToCartCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.productOptionId = _data["productOptionId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): AddToCartCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddToCartCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["productOptionId"] = this.productOptionId;
        data["quantity"] = this.quantity;
        return data;
    }
}

interface IAddToCartCommand {
    productOptionId?: number;
    quantity?: number;

    [key: string]: any;
}

class UserDto implements IUserDto {
    userId?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    phoneNumber?: string;
    address?: string;
    avatarUrl?: string;
    createdAt?: Date;
    permissions?: string[];
    emailVerified?: boolean;
    customer?: boolean;
    accountEnabled?: boolean;

    [key: string]: any;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.address = _data["address"];
            this.avatarUrl = _data["avatarUrl"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.emailVerified = _data["emailVerified"];
            this.customer = _data["customer"];
            this.accountEnabled = _data["accountEnabled"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["address"] = this.address;
        data["avatarUrl"] = this.avatarUrl;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["emailVerified"] = this.emailVerified;
        data["customer"] = this.customer;
        data["accountEnabled"] = this.accountEnabled;
        return data;
    }
}

interface IUserDto {
    userId?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    phoneNumber?: string;
    address?: string;
    avatarUrl?: string;
    createdAt?: Date;
    permissions?: string[];
    emailVerified?: boolean;
    customer?: boolean;
    accountEnabled?: boolean;

    [key: string]: any;
}

class PromotionDto implements IPromotionDto {
    promotionId?: number;
    code?: string;
    name?: string;
    description?: string;
    discount?: number;
    type?: PromotionDtoType;
    minOrderAmount?: number;
    maxValue?: number;
    startDate?: Date;
    endDate?: Date;
    active?: boolean;
    stock?: number;

    [key: string]: any;

    constructor(data?: IPromotionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.promotionId = _data["promotionId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.discount = _data["discount"];
            this.type = _data["type"];
            this.minOrderAmount = _data["minOrderAmount"];
            this.maxValue = _data["maxValue"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.active = _data["active"];
            this.stock = _data["stock"];
        }
    }

    static fromJS(data: any): PromotionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PromotionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["promotionId"] = this.promotionId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["discount"] = this.discount;
        data["type"] = this.type;
        data["minOrderAmount"] = this.minOrderAmount;
        data["maxValue"] = this.maxValue;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["active"] = this.active;
        data["stock"] = this.stock;
        return data;
    }
}

interface IPromotionDto {
    promotionId?: number;
    code?: string;
    name?: string;
    description?: string;
    discount?: number;
    type?: PromotionDtoType;
    minOrderAmount?: number;
    maxValue?: number;
    startDate?: Date;
    endDate?: Date;
    active?: boolean;
    stock?: number;

    [key: string]: any;
}

class CategoryBriefDto implements ICategoryBriefDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    categoryId?: number;
    name?: string;
    parent?: CategoryBriefDto;

    [key: string]: any;

    constructor(data?: ICategoryBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.parent = _data["parent"] ? CategoryBriefDto.fromJS(_data["parent"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CategoryBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        return data;
    }
}

interface ICategoryBriefDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    categoryId?: number;
    name?: string;
    parent?: CategoryBriefDto;

    [key: string]: any;
}

class ColorDto implements IColorDto {
    colorId?: number;
    name?: string;
    image?: string;

    [key: string]: any;

    constructor(data?: IColorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.colorId = _data["colorId"];
            this.name = _data["name"];
            this.image = _data["image"];
        }
    }

    static fromJS(data: any): ColorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ColorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["colorId"] = this.colorId;
        data["name"] = this.name;
        data["image"] = this.image;
        return data;
    }
}

interface IColorDto {
    colorId?: number;
    name?: string;
    image?: string;

    [key: string]: any;
}

class ProductDetailDto implements IProductDetailDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productId?: number;
    name?: string;
    forGender?: ProductDetailDtoForGender;
    slug?: string;
    price?: number;
    discount?: number;
    displayImage?: string;
    category?: CategoryBriefDto;
    deletedDate?: Date;
    productOptions?: ProductOptionDto[];
    images?: ProductImageDto[];
    description?: string;
    finalPrice?: number;
    vietnamesePrice?: string;
    forGenderDisplay?: string;

    [key: string]: any;

    constructor(data?: IProductDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.forGender = _data["forGender"];
            this.slug = _data["slug"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.displayImage = _data["displayImage"];
            this.category = _data["category"] ? CategoryBriefDto.fromJS(_data["category"]) : <any>undefined;
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["productOptions"])) {
                this.productOptions = [] as any;
                for (let item of _data["productOptions"])
                    this.productOptions!.push(ProductOptionDto.fromJS(item));
            }
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ProductImageDto.fromJS(item));
            }
            this.description = _data["description"];
            this.finalPrice = _data["finalPrice"];
            this.vietnamesePrice = _data["vietnamesePrice"];
            this.forGenderDisplay = _data["forGenderDisplay"];
        }
    }

    static fromJS(data: any): ProductDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["forGender"] = this.forGender;
        data["slug"] = this.slug;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["displayImage"] = this.displayImage;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        if (Array.isArray(this.productOptions)) {
            data["productOptions"] = [];
            for (let item of this.productOptions)
                data["productOptions"].push(item.toJSON());
        }
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        data["description"] = this.description;
        data["finalPrice"] = this.finalPrice;
        data["vietnamesePrice"] = this.vietnamesePrice;
        data["forGenderDisplay"] = this.forGenderDisplay;
        return data;
    }
}

interface IProductDetailDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productId?: number;
    name?: string;
    forGender?: ProductDetailDtoForGender;
    slug?: string;
    price?: number;
    discount?: number;
    displayImage?: string;
    category?: CategoryBriefDto;
    deletedDate?: Date;
    productOptions?: ProductOptionDto[];
    images?: ProductImageDto[];
    description?: string;
    finalPrice?: number;
    vietnamesePrice?: string;
    forGenderDisplay?: string;

    [key: string]: any;
}

class ProductImageDto implements IProductImageDto {
    url?: string;
    forColor?: ColorDto;

    [key: string]: any;

    constructor(data?: IProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.url = _data["url"];
            this.forColor = _data["forColor"] ? ColorDto.fromJS(_data["forColor"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["url"] = this.url;
        data["forColor"] = this.forColor ? this.forColor.toJSON() : <any>undefined;
        return data;
    }
}

interface IProductImageDto {
    url?: string;
    forColor?: ColorDto;

    [key: string]: any;
}

class ProductOptionDto implements IProductOptionDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productOptionId?: number;
    size?: string;
    stock?: number;
    deletedDate?: Date;
    color?: ColorDto;

    [key: string]: any;

    constructor(data?: IProductOptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.productOptionId = _data["productOptionId"];
            this.size = _data["size"];
            this.stock = _data["stock"];
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
            this.color = _data["color"] ? ColorDto.fromJS(_data["color"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductOptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["productOptionId"] = this.productOptionId;
        data["size"] = this.size;
        data["stock"] = this.stock;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        return data;
    }
}

interface IProductOptionDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productOptionId?: number;
    size?: string;
    stock?: number;
    deletedDate?: Date;
    color?: ColorDto;

    [key: string]: any;
}

class PaginatedProductBriefDto implements IPaginatedProductBriefDto {
    data?: ProductBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedProductBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ProductBriefDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedProductBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedProductBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedProductBriefDto {
    data?: ProductBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class ProductBriefDto implements IProductBriefDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productId?: number;
    name?: string;
    forGender?: ProductBriefDtoForGender;
    slug?: string;
    price?: number;
    discount?: number;
    displayImage?: string;
    category?: CategoryBriefDto;
    deletedDate?: Date;
    finalPrice?: number;
    vietnamesePrice?: string;
    forGenderDisplay?: string;

    [key: string]: any;

    constructor(data?: IProductBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.forGender = _data["forGender"];
            this.slug = _data["slug"];
            this.price = _data["price"];
            this.discount = _data["discount"];
            this.displayImage = _data["displayImage"];
            this.category = _data["category"] ? CategoryBriefDto.fromJS(_data["category"]) : <any>undefined;
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
            this.finalPrice = _data["finalPrice"];
            this.vietnamesePrice = _data["vietnamesePrice"];
            this.forGenderDisplay = _data["forGenderDisplay"];
        }
    }

    static fromJS(data: any): ProductBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["forGender"] = this.forGender;
        data["slug"] = this.slug;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["displayImage"] = this.displayImage;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        data["finalPrice"] = this.finalPrice;
        data["vietnamesePrice"] = this.vietnamesePrice;
        data["forGenderDisplay"] = this.forGenderDisplay;
        return data;
    }
}

interface IProductBriefDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productId?: number;
    name?: string;
    forGender?: ProductBriefDtoForGender;
    slug?: string;
    price?: number;
    discount?: number;
    displayImage?: string;
    category?: CategoryBriefDto;
    deletedDate?: Date;
    finalPrice?: number;
    vietnamesePrice?: string;
    forGenderDisplay?: string;

    [key: string]: any;
}

class OrderBriefDto implements IOrderBriefDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    orderId?: string;
    customerName?: string;
    address?: string;
    paymentMethod?: OrderBriefDtoPaymentMethod;
    phoneNumber?: string;
    email?: string;
    totalAmount?: number;
    note?: string;
    deliveryFee?: number;
    cancelReason?: string;
    status?: OrderBriefDtoStatus;
    latestPayment?: PaymentDto;
    promotion?: PromotionDto;

    [key: string]: any;

    constructor(data?: IOrderBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.orderId = _data["orderId"];
            this.customerName = _data["customerName"];
            this.address = _data["address"];
            this.paymentMethod = _data["paymentMethod"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.totalAmount = _data["totalAmount"];
            this.note = _data["note"];
            this.deliveryFee = _data["deliveryFee"];
            this.cancelReason = _data["cancelReason"];
            this.status = _data["status"];
            this.latestPayment = _data["latestPayment"] ? PaymentDto.fromJS(_data["latestPayment"]) : <any>undefined;
            this.promotion = _data["promotion"] ? PromotionDto.fromJS(_data["promotion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["orderId"] = this.orderId;
        data["customerName"] = this.customerName;
        data["address"] = this.address;
        data["paymentMethod"] = this.paymentMethod;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["totalAmount"] = this.totalAmount;
        data["note"] = this.note;
        data["deliveryFee"] = this.deliveryFee;
        data["cancelReason"] = this.cancelReason;
        data["status"] = this.status;
        data["latestPayment"] = this.latestPayment ? this.latestPayment.toJSON() : <any>undefined;
        data["promotion"] = this.promotion ? this.promotion.toJSON() : <any>undefined;
        return data;
    }
}

interface IOrderBriefDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    orderId?: string;
    customerName?: string;
    address?: string;
    paymentMethod?: OrderBriefDtoPaymentMethod;
    phoneNumber?: string;
    email?: string;
    totalAmount?: number;
    note?: string;
    deliveryFee?: number;
    cancelReason?: string;
    status?: OrderBriefDtoStatus;
    latestPayment?: PaymentDto;
    promotion?: PromotionDto;

    [key: string]: any;
}

class PaginatedOrderBriefDto implements IPaginatedOrderBriefDto {
    data?: OrderBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedOrderBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(OrderBriefDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedOrderBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedOrderBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedOrderBriefDto {
    data?: OrderBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class PaymentDto implements IPaymentDto {
    paymentId?: string;
    status?: PaymentDtoStatus;
    paymentDetails?: string;
    paymentResponse?: string;
    amount?: number;

    [key: string]: any;

    constructor(data?: IPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.paymentId = _data["paymentId"];
            this.status = _data["status"];
            this.paymentDetails = _data["paymentDetails"];
            this.paymentResponse = _data["paymentResponse"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): PaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["paymentId"] = this.paymentId;
        data["status"] = this.status;
        data["paymentDetails"] = this.paymentDetails;
        data["paymentResponse"] = this.paymentResponse;
        data["amount"] = this.amount;
        return data;
    }
}

interface IPaymentDto {
    paymentId?: string;
    status?: PaymentDtoStatus;
    paymentDetails?: string;
    paymentResponse?: string;
    amount?: number;

    [key: string]: any;
}

class PaginatedCategoryBriefDto implements IPaginatedCategoryBriefDto {
    data?: CategoryBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;

    constructor(data?: IPaginatedCategoryBriefDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryBriefDto.fromJS(item));
            }
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.totalElements = _data["totalElements"];
            this.hasNext = _data["hasNext"];
            this.hasPrevious = _data["hasPrevious"];
        }
    }

    static fromJS(data: any): PaginatedCategoryBriefDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedCategoryBriefDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["totalElements"] = this.totalElements;
        data["hasNext"] = this.hasNext;
        data["hasPrevious"] = this.hasPrevious;
        return data;
    }
}

interface IPaginatedCategoryBriefDto {
    data?: CategoryBriefDto[];
    page?: number;
    pageSize?: number;
    totalPages?: number;
    totalElements?: number;
    hasNext?: boolean;
    hasPrevious?: boolean;

    [key: string]: any;
}

class CartItemDto implements ICartItemDto {
    userId?: string;
    productOptionId?: number;
    quantity?: number;
    productOption?: ProductOptionDetailDto;

    [key: string]: any;

    constructor(data?: ICartItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.userId = _data["userId"];
            this.productOptionId = _data["productOptionId"];
            this.quantity = _data["quantity"];
            this.productOption = _data["productOption"] ? ProductOptionDetailDto.fromJS(_data["productOption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CartItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CartItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["userId"] = this.userId;
        data["productOptionId"] = this.productOptionId;
        data["quantity"] = this.quantity;
        data["productOption"] = this.productOption ? this.productOption.toJSON() : <any>undefined;
        return data;
    }
}

interface ICartItemDto {
    userId?: string;
    productOptionId?: number;
    quantity?: number;
    productOption?: ProductOptionDetailDto;

    [key: string]: any;
}

class ProductOptionDetailDto implements IProductOptionDetailDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productOptionId?: number;
    size?: string;
    stock?: number;
    deletedDate?: Date;
    color?: ColorDto;
    product?: ProductBriefDto;
    quantity?: number;
    finalPrice?: number;
    finalPriceDisplay?: string;

    [key: string]: any;

    constructor(data?: IProductOptionDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.createdBy = _data["createdBy"];
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModifiedDate = _data["lastModifiedDate"] ? new Date(_data["lastModifiedDate"].toString()) : <any>undefined;
            this.productOptionId = _data["productOptionId"];
            this.size = _data["size"];
            this.stock = _data["stock"];
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>undefined;
            this.color = _data["color"] ? ColorDto.fromJS(_data["color"]) : <any>undefined;
            this.product = _data["product"] ? ProductBriefDto.fromJS(_data["product"]) : <any>undefined;
            this.quantity = _data["quantity"];
            this.finalPrice = _data["finalPrice"];
            this.finalPriceDisplay = _data["finalPriceDisplay"];
        }
    }

    static fromJS(data: any): ProductOptionDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOptionDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["createdBy"] = this.createdBy;
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModifiedDate"] = this.lastModifiedDate ? this.lastModifiedDate.toISOString() : <any>undefined;
        data["productOptionId"] = this.productOptionId;
        data["size"] = this.size;
        data["stock"] = this.stock;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>undefined;
        data["color"] = this.color ? this.color.toJSON() : <any>undefined;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["finalPrice"] = this.finalPrice;
        data["finalPriceDisplay"] = this.finalPriceDisplay;
        return data;
    }
}

interface IProductOptionDetailDto {
    createdBy?: string;
    createdDate?: Date;
    lastModifiedBy?: string;
    lastModifiedDate?: Date;
    productOptionId?: number;
    size?: string;
    stock?: number;
    deletedDate?: Date;
    color?: ColorDto;
    product?: ProductBriefDto;
    quantity?: number;
    finalPrice?: number;
    finalPriceDisplay?: string;

    [key: string]: any;
}

class DeleteProductImageCommand implements IDeleteProductImageCommand {
    url!: string;

    [key: string]: any;

    constructor(data?: IDeleteProductImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): DeleteProductImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteProductImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["url"] = this.url;
        return data;
    }
}

interface IDeleteProductImageCommand {
    url: string;

    [key: string]: any;
}

class Body implements IBody {
    file!: string;

    [key: string]: any;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["file"] = this.file;
        return data;
    }
}

interface IBody {
    file: string;

    [key: string]: any;
}

class Body2 implements IBody2 {
    file?: string;

    [key: string]: any;

    constructor(data?: IBody2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.file = _data["file"];
        }
    }

    static fromJS(data: any): Body2 {
        data = typeof data === 'object' ? data : {};
        let result = new Body2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["file"] = this.file;
        return data;
    }
}

interface IBody2 {
    file?: string;

    [key: string]: any;
}

enum ForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum PaymentStatus {
    PENDING = "PENDING",
    PAID = "PAID",
    CANCELLED = "CANCELLED",
    REFUNDED = "REFUNDED",
    FAILED = "FAILED",
}

enum OrderStatus {
    PENDING = "PENDING",
    PROCESSING = "PROCESSING",
    SHIPPING = "SHIPPING",
    DELIVERED = "DELIVERED",
    CANCELLED = "CANCELLED",
    RETURNED = "RETURNED",
    REFUNDED = "REFUNDED",
}

enum UpdateProductCommandForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum CreateProductCommandForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum CreatePaymentResponsePaymentMethod {
    COD = "COD",
    MOMO_QR = "MOMO_QR",
    MOMO_ATM = "MOMO_ATM",
}

enum CreateOrderCommandPaymentMethod {
    COD = "COD",
    MOMO_QR = "MOMO_QR",
    MOMO_ATM = "MOMO_ATM",
}

enum PromotionDtoType {
    PERCENTAGE = "PERCENTAGE",
    FIXED_AMOUNT = "FIXED_AMOUNT",
}

enum ProductDetailDtoForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum ProductBriefDtoForGender {
    FOR_MALE = "FOR_MALE",
    FOR_FEMALE = "FOR_FEMALE",
    FOR_BOTH = "FOR_BOTH",
}

enum OrderBriefDtoPaymentMethod {
    COD = "COD",
    MOMO_QR = "MOMO_QR",
    MOMO_ATM = "MOMO_ATM",
}

enum OrderBriefDtoStatus {
    PENDING = "PENDING",
    PROCESSING = "PROCESSING",
    SHIPPING = "SHIPPING",
    DELIVERED = "DELIVERED",
    CANCELLED = "CANCELLED",
    RETURNED = "RETURNED",
    REFUNDED = "REFUNDED",
}

enum PaymentDtoStatus {
    PENDING = "PENDING",
    PAID = "PAID",
    CANCELLED = "CANCELLED",
    REFUNDED = "REFUNDED",
    FAILED = "FAILED",
}

interface FileParameter {
    data: any;
    fileName: string;
}

interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}